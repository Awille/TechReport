[TOC]



# Binder实现解析

## 1、背景

以往在抽象的基础上理解Binder通信，比如Binder的C/S架构，内存映射、单次复制等等， 但一直没有在实现的层面去看Binder的实现细节。在当前背景下，鸿蒙的出现，苹果 ios系统的AI能力集成，如果一直停留在Android的层面去理解IPC通信的上层实现方式，有些局限，希望通过本次的细节分析，整理出大致的框架，理解在计算机底层是怎么完成一次跨进程通信的，以及Android Binder实现方式的优劣是什么，这种设计的考量是什么。



## 2、Binder架构简介















# 附录

这些概念是与操作系统相关的常见操作和机制，下面是它们的简要介绍：

1. **poll**:
   - **描述**：`poll` 是一个系统调用，用于查询多个文件描述符（文件句柄）是否准备好进行 I/O 操作而不会被阻塞。
   - **工作原理**：通过 `poll` 系统调用，进程可以监视一组文件描述符，确定它们是否已准备好进行读取、写入或异常处理，而无需阻塞等待。
2. **mmap**:
   - **描述**：`mmap`（memory map）是一种通过将文件或设备映射到内存的方式来实现文件 I/O 的机制。
   - **工作原理**：通过 `mmap` 系统调用，进程可以将一个文件或设备映射到其地址空间中的一块内存区域，允许直接在内存中对文件进行读写操作，而不需要通过传统的 `read` 和 `write` 系统调用。
3. **flush**:
   - **描述**：`flush` 是指将缓冲区中的数据刷新（写入）到其对应的实际存储介质（如磁盘）中。
   - **工作原理**：在操作系统中，写入数据通常会首先存储在内存中的缓冲区中，以提高写入效率。`flush` 操作强制将缓冲区中的数据写入到实际的存储介质中，以确保数据的持久性。
4. **ioctl**:
   - **描述**：`ioctl`（input/output control）是一个通用的 I/O 控制系统调用，用于在设备驱动程序和用户空间程序之间进行交互。
   - **工作原理**：`ioctl` 允许用户空间程序向设备驱动程序发送命令以执行各种操作，如配置设备参数、控制设备行为等。它提供了一种灵活的机制，用于处理设备特定的操作，而不需要通过标准的读写操作进行。















