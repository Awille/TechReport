# ImGui Template

## 1、依赖库基本介绍

### 1.1、ImGui

### 1.2、GLFW

Grphic Library FrameWork ， 开源的、跨平台的窗口创建和OpenGL的上下文管理库，用于创建图形用户界面和处理用户输入。它提供了一个简单的、独立于平台的接口，用户创建窗口，处理窗口事件、创建openGL上下文、管理窗口生命周期、处理多窗口和多监视器等任务。

GLFW主要用于游戏开发、图形应用程序、计算机图形学以及其他需要图形界面和用户输入的应用领域。它支持多种平台，包括Windows、macOS、Linux、以及一些嵌入式系统，提供了一致的接口和功能，使得开发者可以跨平台地创建图形应用程序，并处理用户输入。

GLFW具有简单、轻量级、易于集成和使用的特点，它不依赖于任何第三方库，但可以与其他图形库（如OpenGL、Vulkan等）结合使用。GLFW的目标是提供一个稳定、简单和高效的工具，用于创建窗口和处理用户输入，从而使开发者可以专注于图形应用程序的核心逻辑和功能。

openGL与Vulkan

* OpenGL（Open Graphic Library）是一个用于渲染2D和3D图形的跨平台图形编程接口，他提供了一组用于渲染图形的函数和状态机，并允许开发者通过编写图形渲染代码来创建各种图形效果，如三维模型、光照、纹理等。
* Vulkan 是一个现代的、低级别的图形和计算API，用于高性能图形渲染和计算。它被设计为跨平台、高效、可扩展和灵活的图形和计算编程接口，适用于各种硬件和操作系统。



GLFW 不包含任何图形渲染功能，而是与其他图形渲染库（如Vulkan、OpenGL等）结合使用。

在创建图形应用程序时，通常会使用GLFW来创建窗口和处理用户输入，然后使用OpenGL或者Vulkan来进行图形渲染。GLFW提供了方便的窗口和输入管理，使开发者可以专注于图形渲染的逻辑和功能，而无需关心平台特定的窗口和输入处理。



Android渲染底层使用的是OpenGL ES(OpenGL for Embedded Systems)， OpenGL ES 是 OpenGL 的嵌入式版本，专门设计用于嵌入式系统和移动设备，包括智能手机、平板电脑和其他移动设备。在 Android 平台上，OpenGL ES 提供了与 OpenGL 类似的图形渲染功能，但使用了更小的资源和功耗，并且专门针对移动设备的特点进行了优化。OpenGL ES 是一种跨平台的图形渲染 API，被广泛用于 Android 上的游戏、图形应用和其他图形相关的应用开发。Vulkan 也可以在 Android 平台上使用，但它通常用于高性能图形渲染和计算，适用于需要更大控制权和更高性能的应用场景，例如游戏引擎、3D建模和渲染应用等。Vulkan 是一种现代的、低级别的图形和计算 API，具有更高的性能和灵活性，但同时也需要更复杂的编程和管理。

* Glad是一个用于管理和加载OpenGL（或者OpenGL ES）函数指针的C/C++库。它可以帮助简化OpenGL的初始化过程，使得在使用OpenGL时更加方便和灵活。

  在使用OpenGL时，需要通过函数指针调用OpenGL的各种函数。不同的操作系统和硬件平台可能提供不同的OpenGL库，并且可能有不同的函数指针加载方式。Glad可以生成适用于特定平台的加载OpenGL函数指针的代码，从而简化了加载和管理OpenGL函数指针的过程。

  Glad支持多种不同的加载方式，包括静态加载和动态加载，可以生成C/C++的头文件和源文件，方便集成到项目中。Glad还支持多个OpenGL版本和扩展，可以通过简单的配置选项来生成所需的OpenGL函数指针加载代码。

  使用Glad可以使得在使用OpenGL时更加灵活，可以方便地切换OpenGL版本和扩展，以及支持多个平台和编译器。它是一个常用的工具库，用于简化OpenGL的初始化和函数指针加载过程。

  可以理解为该库，对gpu中的openGL实现函数做了声明，他的作用时让你可以访问那些已经存在于你的电脑的二进制形式函数





### 1.5、dll与lib

在 Windows 操作系统下，.dll 和 .lib 是两种不同类型的文件，分别用于动态链接库（Dynamic Link Library，简称 DLL）和静态链接库（Static Library）。

区别如下：

1. 动态链接库（.dll）：是一种可执行文件，包含已编译的代码和数据，可以在运行时被加载和链接到程序中。动态链接库允许多个程序共享同一个库，从而节省内存和磁盘空间。动态链接库的代码和数据在程序运行时被加载到内存中，使得程序可以在运行时加载和卸载库，从而动态地扩展和更新功能。
2. 静态链接库（.lib）：是一种在编译时被链接到程序中的库，包含已编译的代码和数据。静态链接库在编译时被链接到目标程序中，形成一个独立的可执行文件，包含了所有需要的代码和数据，无需在运行时加载外部库。静态链接库在编译时被复制到目标程序中，从而使得程序可以独立地运行，不依赖于外部库的存在。

区别总结如下：

- .dll 是动态链接库，包含可在运行时加载和链接的代码和数据。
- .lib 是静态链接库，包含在编译时链接到目标程序中的代码和数据。
- 动态链接库可以在运行时被加载和卸载，允许多个程序共享同一个库。
- 静态链接库在编译时被链接到目标程序中，形成一个独立的可执行文件，无需在运行时加载外部库。



## 2、openGL基础

https://docs.gl/  openGL文档

### 2.1、VertexBuffer（顶点缓冲区）

一个缓冲区，内存缓冲区、一个数组。 比如我想定义一组数据来表示我的三角形，我想把他放到GPU VRAM当中。  一个着色器只是一个运行在GPU上的程序，他是一堆我们可以编写的在GPU上运行的代码。 我们把数据放到GPU VRAM当中，然后告诉GPU解释这个数据的方式。 我们设置一系列状态，然后让GPU进行工作。

我想让你选择这个缓冲区、我想让你选择这个着色器，然后根据你选的缓冲和着色器，向右画一个三角形。



一个vertex是图像中一个点的属性，这里面的属性可以包含 位置、纹理坐标、法线等。

假设一个vertext组成为：

* float 三元组、表示空间中的坐标位置
* float 二元组、表示纹理坐标

那么一个vertex的大小为 （3+2）* 4 = 20bytes  我们需要在程序中告诉openGL如何布局



### 2.1、GLSL

GLSL（OpenGL Shading Language）是一种用于编写图形渲染着色器的编程语言。它是专门为OpenGL（Open Graphics Library）图形渲染API设计的着色器语言，用于在GPU上执行图形渲染任务。

GLSL提供了一种用于定义图形渲染效果的灵活且高性能的编程方式。它允许开发者编写各种类型的着色器，包括顶点着色器、片段着色器、几何着色器等，用于控制图形渲染管线中的不同阶段，从而实现高度定制化的渲染效果。



### 2.2、顶点

在计算机图形学中，顶点（Vertex）是指三维模型中的一个离散点，通常用于描述模型的形状和外观。顶点可以包含多个属性，如位置、颜色、法线、纹理坐标等，这些属性的值决定了顶点在三维空间中的位置、颜色和其他属性。

顶点数据的结构可以根据不同的需求而变化，但通常包括以下几个属性：

1. 顶点位置（Vertex Position）：描述了顶点在三维空间中的位置，通常由三个浮点数（x、y、z）表示。
2. 顶点颜色（Vertex Color）：描述了顶点的颜色属性，通常由四个浮点数（r、g、b、a）表示，分别表示红色、绿色、蓝色和透明度。
3. 顶点法线（Vertex Normal）：描述了顶点在三维空间中的法线方向，用于计算光照效果。通常由三个浮点数（nx、ny、nz）表示。
4. 纹理坐标（Texture Coordinate）：描述了顶点在纹理贴图中的位置，通常由两个浮点数（u、v）表示，用于在纹理贴图上定位顶点的纹理信息。

顶点缓冲区（Vertex Buffer）和索引缓冲区（Index Buffer）是在计算机图形学中常用的两种缓冲区，用于存储顶点数据和索引数据，分别用于描述三维模型的顶点属性和顶点连接关系。

* 顶点缓冲区是一块内存区域，用于存储顶点数据，包括顶点的位置、颜色、法线、纹理坐标等属性。顶点缓冲区可以被图形渲染器访问，从而实现对顶点数据的读取和修改。顶点缓冲区通常由应用程序创建和管理，并在渲染过程中被绑定到图形渲染管线中的输入装配阶段（Input Assembly Stage），用于传递顶点数据给渲染器进行处理。
* 索引缓冲区是一块内存区域，用于存储顶点连接关系的索引数据。索引数据通常使用整数类型的索引值，指示顶点缓冲区中的顶点在渲染过程中的连接关系。通过使用索引缓冲区，可以避免在顶点缓冲区中重复存储相同的顶点数据，从而节省存储空间和提高渲染性能。





### 2.3、Shaders 着色器

解释vertex数据，并绘制的角色。

vertex shader: 每个vertex  vertex shader会被调用一次，三角形三个顶点就会被调用三次，用于告诉openGL 你希望这个vertex在你的屏幕空间的哪个位置

fragement shader： the frgament shader is going to run once for each pixel that need to get rasterized. 



### 2.4、IndexBuffer

索引缓冲区，避免重复的内存



## C++基础

### 1、指针

```c++
int* ptr = reinterpret_cast<int *>(2);
```

* ptr: 指针对象存储的内存地址
* &ptr: 指针对象自己的内存地址
* *ptr: 指针对象存储的内存地址指向的值

指向指针的指针

```c++
GLFWAPI GLFWmonitor** glfwGetMonitors(int* count);
```

在 C/C++ 中，指针是一个存储变量内存地址的变量，而指针的指针则是一个存储指针变量的地址的变量。

GLFWmonitor**该指针变量存储了一个GLFWmonitor\* 的地址，即指向了GLFWmonitor\*这个指针对象

### 2、函数型指针

在 C++ 中，可以使用以下语法来定义函数指针：

返回值类型 (*指针变量名称)(参数列表)；

```c++
// 假设有一个函数的原型如下：
int foo(int a, int b);

// 定义一个函数指针，指向该函数
int (*ptr)(int, int);

// 将函数赋值给函数指针
ptr = foo;

// 通过函数指针调用函数
int result = ptr(2, 3);  // 调用 foo 函数，传入参数 2 和 3
```

函数型指针的入参与返回值必须与原函数完全相同，否则会产生异常，可以用tydef来简化函数型指针的定义

```c++
typedef int (*FooFunc)(int, int);  // 定义一个函数指针类型 FooFunc

FooFunc ptr = foo;  // 使用函数指针类型定义并赋值
```

### 3、typedef

该关键字可以给函数、变量取别名，使得代码更清晰易懂

* 别名定义

  ```c++
  typedef int myInt;  // 定义 myInt 作为 int 的别名
  myInt num = 42;     // 使用 myInt 定义变量 num
  ```

* 简化复杂类型

  ```c++
  typedef std::vector<int> IntVector;  // 定义 IntVector 作为 std::vector<int> 的别名
  IntVector v;                         // 使用 IntVector 定义变量 v
  ```

* 可移植性：通过 `typedef` 可以在不同平台或编译器上使用相同的别名，提高代码的可移植性。例如：

  ```c++
  typedef unsigned long long ULL;  // 定义 ULL 作为 unsigned long long 的别名
  ULL num = 123456789ULL;         // 使用 ULL 定义变量 num，并指定后缀 ULL 表示无符号长长整数
  ```

c++11以后，推荐使用using代替typedef

```c++
using myInt = int;  // 使用 using 关键字定义 myInt 作为 int 的别名
myInt num = 42;     // 使用 myInt 定义变量 num
```



### 4、__restrict

`__restrict` 是 C 语言中的一个限定符，用于提示编译器某个指针指向的内存区域不会被其他指针访问，从而可能进行一些优化。它的作用是告诉编译器，某个指针是独占的，不会与其他指针重叠，从而允许编译器在生成机器码时进行一些优化，提高程序的性能。

```c++
int	 fprintf(FILE * __restrict, const char * __restrict, ...) __printflike(2, 3);
```

简单点来说，就是在告诉编译在程序运行时，同一时刻，只存在一个指针指向该对象，编译器可以基于此进行优化

使用 `__restrict` 限定符时，应确保对应的指针在其生命周期内不会与其他指针重叠，否则可能导致未定义行为。这意味着在使用 `__restrict` 限定符时，需要谨慎考虑指针的使用方式和生命周期，以避免出现潜在的错误。



```c++
fprintf(stderr, "Glfw Error %d: %s\n", error, description);
```

在 C/C++ 中，`stderr` 是一个预定义的文件流指针，用于表示标准错误输出流。它通常与 `stdio.h` 头文件一起使用，该头文件中定义了标准输入、标准输出和标准错误输出的相关函数和对象。

在调用 `fprintf` 函数时，`stderr` 对象是作为第一个参数传递给函数的，用于指定输出流的目标。`stderr` 对象是一个 `FILE` 类型的指针，通常指向一个与标准错误输出流相关联的文件描述符。

在标准的 C/C++ 环境中，`stderr` 对象的定义和赋值通常由系统或编译器提供，无需手动赋值。在不同的操作系统和编译器中，`stderr` 对象的具体定义和赋值方式可能会有所不同，例如在 Linux 系统中，`stderr` 对象可能被定义为一个文件描述符指针，指向标准错误输出流的文件描述符。具体的定义和赋值方式可以在系统的 C/C++ 标准库或编译器的头文件中找到。

### 5、__printflike

`__printflike(2, 3)` 是一个函数属性（function attribute）， 在C语言中用于告诉编译器函数的参数和格式化字符串之间的关系，以便进行编译时的类型检查和格式化字符串的安全性检查。在这个函数声明中，`__printflike(2, 3)` 意味着函数的第二个参数是格式化字符串，而第三个参数是变参参数（例如`...`），并且格式化字符串的语法将类似于`printf`函数。这样编译器在调用这个函数时可以进行类型检查和格式化字符串的安全性检查，以避免潜在的格式化字符串漏洞（如格式化字符串攻击）。

### 6、函数声明与函数定义

在C语言和C++中，函数声明可以省略参数的变量名，只提供参数的类型。这种声明方式通常在函数原型（function prototype）中使用，用于指定函数的参数类型和返回类型，而不需要实际的参数变量名。

在函数声明中省略参数变量名的主要目的是为了在函数原型中定义函数的接口，即指定参数的类型和返回类型，而不关心参数的具体名称。这样可以使函数原型更加简洁，减少冗余信息，并提高代码的可读性。

在函数定义中，参数变量名是必需的，因为函数定义需要实际的参数变量名来接收函数调用时传入的实际参数值。而在函数声明中，只需要指定参数的类型和返回类型，不需要具体的参数变量名，因为参数变量名在函数声明中没有实际的作用。

### 7、全局函数

`glfwSetErrorCallback` 是一个静态函数，因为它属于 GLFW 库的全局函数，而不是某个特定的对象的成员函数。静态函数是通过类名或者命名空间来调用的，不需要创建对象实例。全局函数是指定义在全局作用域中的函数，不属于任何类或者命名空间的成员函数。全局函数可以在任何地方被调用，不需要创建对象实例或者引入特定的命名空间。

与其他函数的区别主要有以下几点：

1. 作用域：全局函数的作用域是整个源文件，可以在文件中的任何地方调用。而其他函数（如类成员函数或者命名空间中的函数）的作用域限定在类或者命名空间的范围内，需要通过对象实例或者命名空间来访问。
2. 对象关联性：全局函数没有与特定对象关联的数据或者状态，因为它不属于任何类的成员函数。而其他函数通常与类的对象关联，可以访问类的成员变量和成员函数。
3. 命名空间：全局函数不属于任何命名空间，而其他函数可以定义在命名空间中，需要通过命名空间限定符来访问。
4. 访问权限：全局函数可以访问全局变量和其他全局函数，而其他函数可以访问类的私有成员和受保护成员（如果有适当的访问权限），以及所属命名空间中的其他函数和变量。

需要注意的是，全局函数在设计时需要考虑命名冲突的问题，因为它们不属于任何类或者命名空间，容易与其他全局函数或者变量发生命名冲突。因此，在使用全局函数时，应该选择合适的命名和命名空间管理方式，以避免潜在的命名冲突问题。

### 8、new 操作

```c++
#define IM_NEW(_TYPE)       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
```

定义一个宏名称是IM_NEW，入参是_TYPE，返回值是_TYPE， 操作是new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE)))  

因此，**这段代码的作用是在通过 `ImNewWrapper()` 返回的内存地址上，使用定位 `new` 操作符创建一个 `_TYPE` 类型的对象，并调用 `_TYPE` 类型的构造函数来初始化该对象。**这种用法可以用于在指定的内存地址上创建对象，例如在特定的内存池或缓冲区中分配内存，并在这些内存中构造对象。需要注意的是，使用定位 `new` 操作符时需要手动调用对象的析构函数来销毁对象，并释放对应的内存。



```c++
class MyMemoryPool {
public:
    void* allocate(size_t size) {
        // 从内存池中分配指定大小的内存
        // 返回分配的内存地址
    }

    void deallocate(void* ptr, size_t size) {
        // 将内存池中的指定内存地址释放
    }
};
class MyObject {
public:
    MyObject() {
        // 构造函数逻辑
    }

    ~MyObject() {
        // 析构函数逻辑
    }
};

MyMemoryPool myMemoryPool;  // 实例化自定义的内存池对象

// 从内存池中分配一块大小为 sizeof(MyObject) 的内存
void* memory = myMemoryPool.allocate(sizeof(MyObject));

// 使用定位 new 操作符在分配的内存上构造 MyObject 对象
MyObject* obj = new (memory) MyObject();

// ...
// 使用 obj 对象进行操作
// ...

// 手动调用析构函数来销毁 obj 对象
obj->~MyObject();

// 将分配的内存地址返回给内存池
myMemoryPool.deallocate(memory, sizeof(MyObject));

```

